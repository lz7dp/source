{--------------------------------------------------------------------------}
{$I Solver.inc}    {T┐лo нa мoд│л зa из╖иcл┐вaнe нa apи▓мe▓и╖ни изpaзи     }
IMPLEMENTATION     {-------------------------------------------------------}
  USES Util, R_stack, Dat_solv, NB_trees, L_lists1, Scanner;
  TYPE   Equation_pointer = ^Equation_type;
    Equation_type =        { Tип, c║xpaн┐вa╣ дaнни▓e зa apи▓мe▓и╖ни┐ изpaз }
       RECORD
         Equation : L_list;          { Укaзa▓eл к║м apи▓мe▓и╖ни┐ изpaз     }
         Real_val : REAL             { C▓oйнoc▓ нa apи▓мe▓и╖ни┐ изpaз      }
       END;
  VAR Var_root   : NB_tree;          { Kopeн нa о▒новно▓о д║pвo            }
      Exit_place : WORD;             { M┐c▓o зa aвapиeн изxoд              }
      Last_error : STRING;           { Teкc▓ нa пocлeдна▓a гpe╕кa          }
{--------------------------------------------------------------------------}
{$F+}       { Ф│нк╢и┐, дe┤иниpa╣a oпepa╢и┐▓a cpaвн┐вaнe нa cимвoлни низoвe }
  FUNCTION Compare_string (VAR X,Y ) : INTEGER;     { Peз│л▓a▓ -1, 0 или 1 }
    VAR Xs : String_id ABSOLUTE X;   Ys : String_id ABSOLUTE Y;
  BEGIN { Compare_string }
    IF Xs < Ys THEN    Compare_string := -1
    ELSE  IF Xs = Ys THEN  Compare_string :=  0
          ELSE             Compare_string :=  1
  END { Compare_string };
{$F-} {--------------------------------------------------------------------}
PROCEDURE Error (Message :STRING);                   { Oбpaбo▓вa гpe╕ки▓e  }
BEGIN { Error }
  Last_error := Message;    Long_exit(Exit_place);
END { Error };
{--------------------------------------------------------------------------}
PROCEDURE No_error;                                          { H┐мa гpe╕кa }
BEGIN { No_error }
  Last_error := ''
END { No_error };
{--------------------------------------------------------------------------}
FUNCTION Get_last_error;                         { Bp║╣a пocлeднa▓a гpe╕кa }
BEGIN { Get_last_error }
  Get_last_error := Last_error;
END { Get_last_error };
{--------------------------------------------------------------------------}
PROCEDURE Set_message(Message :STRING);               { Oбpaбo▓вa гpe╕ки▓e }
BEGIN { Set_message }
  Last_error := Message;
END { Set_message };
{$F+ }{--------------------------------------------------------------------}
PROCEDURE Comp   { Oбpaбo▓вa eдин eлeмeн▓ o▓ изpaз, зaпиcaн в пoлcки зaпиc }
          (L: L_pointer);                     { Укaзa▓eл к║м ▓ози eлeмeн▓  }
  VAR Value,R1,R2 : REAL;
      Err   : BOOLEAN;         Key   : Oper;       Data  : POINTER;
BEGIN { Comp }     Err := TRUE;
  Key := L_get_key(L);                    { Извли╖a ▓ипa нa eлeмeн▓a       }
  Data:= L_get_data(L);                   { Извли╖a дaнни▓e зa eлeмeн▓a    }
  IF (Key = Variable) OR              { Oбpaбo▓вaни┐▓ eлeмeн▓ e пpoмeнливa }
     (Key = Const_number) THEN        { Oбpaбo▓вaни┐▓ eлeмeн▓ e кoнc▓aн▓a  }
       Err := NOT Push ( REAL(Data^))
  ELSE                                 { Oбpaбo▓вaни┐▓ eлeмeн▓ e oпepa╢и┐  }
    BEGIN
      IF Pop (R1) THEN              { O▓ c▓eкa ce извли╖a п║pви┐▓ oпepaнд  }
        CASE  Key  OF               { Aнaлиз нa ▓ипa нa oпepa╢и┐▓a         }
          Un_plus  : Err := NOT Push (R1);          { Едноме▒▓ен пл╛c      }
          Un_minus : Err := NOT Push (-R1);         { Едноме▒▓ен мин│c     }
          B_plus   : IF Pop (R2) THEN               { Oпepa╢и┐ c║биpaнe    }
                       Err := NOT Push (R1+R2);
          B_minus  : IF Pop (R2) THEN               { Oпepa╢и┐ извaждaнe   }
                       Err := NOT Push (R2-R1);
          Mult     : IF Pop (R2) THEN               { Oпepa╢и┐ │мнoжeниe   }
                       Err := NOT Push (R1*R2);
          Divide   : IF Pop (R2) THEN               { Oпepa╢и┐ дeлeниe     }
                       IF ABS (R1) > 1.0E-20 THEN   { Дeлeниe нa н│лa ?    }
                         Err := NOT Push (R2/R1);
          Sin_op   : Err := NOT Push (SIN(R1));     { Cин│c                }
          Cos_op   : Err := NOT Push (COS(R1));     { Kocин│c              }
          Exp_op   : Err := NOT Push (EXP(R1));     { Eкcпoнeн▓a           }
          Ln_op    : Err := NOT Push (LN(R1));      { Ha▓│paлeн лoгapи▓║м  }
          Sqrt_op  : IF ABS(R1) > 1.0E-20 THEN      { Kвaдpa▓eн кopeн      }
                       Err := NOT Push (SQRT(R1));
          Tg_op    : IF POP (R2) THEN               { Taнгeнc              }
                       IF ABS(R1)> 1.E-10 THEN
                         Err := NOT Push(SIN(R2)/COS(R1))
        END { Case }
    END;
    IF Err THEN
      Error('Heпpaвилeн изpaз')
END { Comp };
{--------------------------------------------------------------------------}
PROCEDURE Compute_value        { Из╖иcл┐вa изpaза, зaпиcaн в пoлcки зaпиc  }
          (Expr    : Equation_pointer;   { Укaзa▓eл к║м изpaзa             }
       VAR VALUE   : REAL;               { Из╖иcлeнa c▓oйнoc▓              }
       VAR  Rezult : BOOLEAN);   { Peз│л▓a▓ o▓ пpecм┐▓aнe▓o:FALSE - гpe╕кa }
  VAR  R : REAL;
BEGIN { Compute_value }
  Rezult := FALSE;    Init_stack ;      Exit_place := Save_exit;
  WITH Expr^ DO
    BEGIN                     { Из╖иcлв┐вa изpaзa, зaпиcaн в пoлcки зaпиc  }
      IF NOT L_process_until (Equation, Null_func, Comp) THEN
        BEGIN                          { Из╖иcлeниe▓o e пpикл╛╖илo │cпe╕нo }
          IF Pop (Value) THEN            { Извли╖aнe на peз│л▓a▓a o▓ c▓eкa }
            BEGIN   Real_val := Value;
              Rezult :=  NOT Pop (R);      { Aкo имa дaнни в c▓eкa - гpe╕кa}
            END
          ELSE
            Set_message ( 'Heпpaвилeн пoлcки зaпиc' )
        END
    END { With };
END { Compute_value };
{$F+  - -------------------------------------------------------------------}
PROCEDURE Del (L: L_pointer);           { Ocвoбoждaвa пaмe▓▓a зa кoнc▓aн▓и }
 VAR Real_pointer : ^REAL ;
BEGIN { Del }
  IF L_get_key(L) = Const_number THEN
    BEGIN   Real_pointer := L_get_data (L);
      DISPOSE (Real_pointer)
    END
END { Del };
{--------------------------------------------------------------------------}
FUNCTION Define_expression;                             { Дe┤иниpa изpaз   }
  VAR Sym    : Symbol;                                  { Tип нa лeкceмa▓a }
      Id_val : String_id;                               { Лeкceмa          }
      Var_data : Equation_type;
      Name     : String_id;
      Success,Rezult : BOOLEAN;                       { Пoмo╣ни пpoмeнливи }
      Place  : POINTER;
      S      : L_list;
{--------------------------------------------------------------------------}
  PROCEDURE Put_data      { Bкл╛╖вa дaнни зa apи▓мe▓и╖ни┐ изpaз в cпиc║кa  }
            (Operat : Oper;                 { Tип нa oпepa╢и┐▓a            }
             Id     : String_id);           { C▓oйнoc▓ нa лeкceмa▓a        }
  VAR Node : POINTER;
      Code : INTEGER;         Real_pointer : ^REAL;     V  : L_pointer;
  BEGIN { Put_data }
    IF Operat <> No_op THEN
      BEGIN
        IF Operat = Variable THEN                { Paзпoзнa▓a e пpoмeнливa }
          BEGIN                  { Извли╖aнe нa нeйни┐ aдpec o▓ NB-д║pвo▓o }
            IF NB_where_node (Var_root, Id, Node) THEN
              L_insert_last (S, Operat,@Equation_pointer(Node)^.Real_val, V)
            ELSE                             { Пpoмeнливa▓a нe e в д║pвo▓o }
              Error ('Heдe┤иниpaнa пpoмeнливa')
          END
        ELSE
          IF Operat = Const_number THEN           { Paзпoзнa▓a e кoнc▓aн▓a }
            BEGIN  NEW (Real_pointer); { Peзepвиpa ce м┐c▓o зa c▓oйнoc▓▓a й}
              VAL (Id, Real_pointer^, Code);
              IF Code = 0 THEN
                L_insert_last (S, Operat, Real_pointer, V)
              ELSE
                BEGIN   DISPOSE (Real_pointer);
                  Error (' Heпpaвилнo п░еоб░аз│ване')
                END
            END
          ELSE                         { Paзпoзнa▓a e oпepa╢и┐ или ┤│нк╢и┐ }
            L_insert_last (S, Operat, NIL, V)
      END
  END { Put_data };
  {------------------------------------------------------------------------}
  PROCEDURE Expression;                     { Aнaлизиpa apи▓мe▓и╖eн изpaз  }
    VAR Op : Oper;      Id : String;
    {----------------------------------------------------------------------}
    PROCEDURE Term;                           { Oбpaбo▓вa ▒║би░аемо (▓е░м) }
      VAR Op : Oper;
      {--------------------------------------------------------------------}
      PROCEDURE Factor;                             { Oбpaбo▓вa мнoжи▓eл   }
        VAR Op : Oper;
      BEGIN { Factor }
        IF Sym = Ident THEN
          BEGIN Put_data (Variable, Id_val);    { Paзпoзнa▓a e пpoмeнливa  }
            Sym := Get_sym(Id_val)
          END
        ELSE
          IF Sym = Number THEN           { Paзпoзнa▓a e ╢и┤poвa кoнc▓aн▓a  }
            BEGIN  Id := Id_val;                  Sym := Get_sym(Id_val);
              IF Sym = Period THEN            { Aнлиз нa peaлнa кoнc▓aн▓a  }
                BEGIN Id := Id + Id_val;          Sym := Get_sym (Id_val);
                  IF Sym = Number THEN
                    BEGIN Id := Id + Id_val;      Sym := Get_sym (Id_val);
                      IF Sym = Exp_sym THEN
                        BEGIN  Id := Id + Id_val; Sym := Get_sym (Id_val);
                          IF Sym = Number THEN
                            BEGIN
                              Id := Id + Id_val;  Sym := Get_sym (Id_val)
                            END
                          ELSE
                            Error ('Heпpaвилeн изpaз')
                        END
                    END
                  ELSE
                    Error ('Heпpaвилeн изpaз')
                END;
              Put_data (Const_number, Id)
            END
          ELSE
            IF Sym = Left_par THEN
              BEGIN  Sym := Get_sym (Id_val);
                Expression;
                IF Sym = Right_par THEN
                  Sym := Get_sym(Id_val)
                ELSE
                  Error('Липcвa д┐cнa cкoбa '')''')
              END
            ELSE
              IF Sym IN [Sin_sym .. Tg_sym] THEN
                BEGIN
                  CASE Sym OF
                    Sin_sym : Op := Sin_op;
                    Cos_sym : Op := Cos_op;
                    Exp_sym : Op := Exp_op;
                    Ln_sym  : Op := Ln_op;
                    Sqrt_sym: Op := Sqrt_op;
                    Tg_sym  : Op := Tg_op
                  END;
                  Sym := Get_sym (Id_val);
                  IF Sym = Left_par THEN
                    BEGIN    Sym := Get_sym (Id_val);
                      Expression;
                      IF Sym = Right_par THEN
                        Sym := Get_sym(Id_val)
                      ELSE
                        Error('Липcвa д┐cнa cкoбa '')''');
                      Put_data (Op,'')
                    END
                END
              ELSE
                Error('Heпpaвилeн изpaз')
      END { Factor };
    {----------------------------------------------------------------------}
    BEGIN { Term }         Factor;
      WHILE Sym IN [Asterisk,Slash] DO
        BEGIN
          CASE Sym OF
            Asterisk : Op := Mult;                { Cлeдвa╣и┐▓ cимвoл e * }
            Slash    : Op := Divide               { Cлeдвa╣и┐▓ cимвoл e / }
          END;
          Sym := Get_sym (Id_val);   Factor;   Put_data (Op,'')
        END
    END { Term };
    {----------------------------------------------------------------------}
  BEGIN { Expression }     Op := No_op;
    IF Sym IN [Plus, Minus] THEN       { Aнaлиз зa едноме▒▓ен пл╛c и мин│c }
      BEGIN
        CASE Sym OF
          Plus : Op := Un_plus;
          Minus: Op := Un_minus
        END;
        Sym := Get_sym(Id_val);
      END;
    Term;         Put_data (Op,'');
    WHILE Sym IN [Plus,Minus] DO
      BEGIN
        CASE Sym OF
          Plus : Op := B_plus;
          Minus: Op := B_minus
        END;
        Sym := Get_sym(Id_val);     Term;     Put_data(Op,'')
      END
  END { Expression };
  {------------------------------------------------------------------------}
  PROCEDURE Process_expression          { Oбpaбo▓вa д┐cнa▓a ╖ac▓ нa изpaз  }
            (VAR Success : BOOLEAN);
  BEGIN { Process_expression }
    Success := FALSE; Exit_place := Save_exit;         { Изxoд пpи гpe╕кa  }
    Expression;       Success := TRUE       { Изpaз║▓ e пpecмe▓нa▓ │cпe╕нo }
  END { Process_expression };
{--------------------------------------------------------------------------}
BEGIN { Define_expression }            { Дe┤иниpaнe нa apи▓мe▓и╖eн изpaз   }
  Success := FALSE;   No_error;
  IF Init_scanner (Memory, In_string) THEN
    BEGIN  Sym := Get_sym(Id_val);       { Пoдгo▓oвкa зa лeкcикaлeн aнaлиз }
      IF Sym = Ident THEN    { Извли╖aнe нa идeн▓и┤икa▓opa нa пpoмeнливa▓a }
        BEGIN     { T║pcи ▓oзи идeн▓и┤икa▓op в д║pвo▓o нa идeн▓и┤икa▓opи▓e }
          Name := Id_val;
          IF NB_where_node (Var_root, Id_val, Place) THEN
                                  { Пpoмeнливa c║c c║╣o▓o имe e дe┤иниpaнa }
          WITH Equation_pointer(Place)^ DO
            BEGIN  L_delete_list (Equation, Del); {O▓c▓paн┐вa c▓apи┐ изpaз }
              L_init (Equation);         S := Equation;
            END
          ELSE
            BEGIN { Hoв идeн▓и┤икa▓op нa пpoмeнливa - вкл╛╖вa ce в д║pвo▓o }
                           { C║здaвa ce нoв пpaзeн cпиc║к зa пoлcки┐ зaпиc }
              L_init(Var_data.Equation);    S := Var_data.Equation;
              IF NOT NB_insert_node (Var_root, Id_val, Var_data)THEN
                BEGIN                                 { Heв║змoжeн cл│╖aй  }
                  Set_message(' B║▓pe╕нa гpe╕кa в NB_trees');
                  Define_expression := FALSE;     EXIT
                END
            END
       END
     ELSE
       BEGIN
         Set_message (' Гpe╕кa в изpaзa ');
         Define_expression := FALSE;     EXIT
       END;
     Sym := Get_sym(Id_val);    { Извли╖aнe нa знaкa зa paвeнc▓вo '=' }
     IF Sym = Equal THEN
       BEGIN
         Sym:=Get_sym(Id_val);       Process_expression (Success);
       END
     ELSE
       BEGIN    Set_message (' Липcвa знaк зa paвeнc▓вo');
         Define_expression := FALSE;     EXIT
       END;
     IF Success THEN
       Success := Compute_expression (Name, Value);
     Define_expression := Success
  END
END { Define_expression };
{$F+ }{--------------------------------------------------------------------}
PROCEDURE Release_var     { Из▓pивa дaнни▓e, cв║pзaни c в║зeл o▓ NB_д║pвo  }
          (Data : POINTER);
BEGIN { Release_var }
 IF Data <> NIL THEN
   WITH Equation_pointer(Data)^ DO
     IF Equation <> NIL THEN
       L_delete_list (Equation ,Del);  { Из▓pивa cпиc║кa, c║д║pжa╣ изpaзa }
END { Release_var };
{$F- }{-------------------------------------------------------------------}
PROCEDURE Release_variable;           { Ocвoбoждaвa пaмe▓▓a нa пpoмeнливa }
  VAR Sym    : Symbol;          Id_val : String_id;
BEGIN { Release_variable }      No_error;
  IF Init_scanner (Memory, In_string) THEN
    BEGIN                         { Извли╖a идeн▓и┤икa▓opa нa пpoмeнливa▓a }
      Sym := Get_sym (Id_val);
      IF Sym = Ident THEN
        BEGIN                          { Из▓pивa идeн▓и┤икa▓opa o▓ д║pвo▓o }
          IF NOT NB_delete_node (Var_root, Id_val) THEN
            Set_message ('Heдe┤иниpaнa пpoмeнливa')
        END
      ELSE
        Set_message ('Heпpaвилeн идeн▓и┤икa▓op')
    END
END { Release_variable };
{---------------------------------------------------------------------------}
FUNCTION Compute_expression;       { Пpecм┐▓a изpaз, зaпиcaн в пoлcки зaпиc }
  VAR Expr   : POINTER;     Rezult : BOOLEAN;    Sym    : Symbol;
      Id_val : String_id;
BEGIN { Comp_expression }
  Compute_expression := FALSE;
  No_error;
  IF Init_scanner (Memory, In_string) THEN
    BEGIN  Sym := Get_sym(Id_val);         { Извли╖a имe▓o нa пpoмeнливa▓a }
      IF Sym = Ident THEN
        BEGIN                        { T║pcи в д║pвo▓o нa идeн▓и┤икa▓opи▓e }
          IF NB_where_node (Var_root, Id_val, Expr) THEN
            BEGIN                              { T║pceни┐▓ в║зeл e нaмepeн }
              Compute_value (Expr, Value, Rezult);
              IF Rezult THEN
                Compute_expression := TRUE
            END
        END
    END
END { Comp_expression };
{-------------------------------------------------------------------------}
BEGIN { Solver }     No_error;
  NB_init (Var_root, NB_null_proc, Release_var, Compare_string,
           SizeOf(String_id), SizeOf(Equation_type) )
END { Solver }.
{-------------------------------------------------------------------------}
