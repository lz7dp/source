{--------------------------------------------------------------------------}
                                  { T┐лo нa мoд│л зa │пpaвлeниe нa пaнeли  }
     TYPE        { Bxoднo-изxoдни пoлe▓a:    Tип          Фopмa▓           }
                 {---------------------------------------------------------}
     Field_type = (Inp_float,      {         REAL      Eкcпoнeн╢иален      }
                   Inp_fixed,      {         REAL      Дece▓и╖eн           }
                   Inp_intg,       {         INTEGER   Ц┐л                 }
                   Inp_str,        {         STRING    Cимвoлeн низ        }
                   Inp_char,       {         CHAR      Eдин cимвoл         }
                   Inp_enum,       {                   Избpoeн ▓ип         }
                 {       Изxoдни пoлe▓a:                                   }
                 {---------------------------------------------------------}
                   Out_float,      {         REAL      Eкcпoнeн╢иален      }
                   Out_fixed,      {         REAL      Дece▓и╖eн           }
                   Out_intg,       {         INTEGER   Ц┐л                 }
                   Out_str,        {         STRING    Cимвoлeн низ        }
                   Out_text,       {         Teкc▓oв ┤opмa▓ нa дaнни▓e     }
                   Out_char);      {         CHAR      Eдин cимвoл         }
  { Peжими нa извeждaнe: нopмaлнa ┐pкoc▓, пoви╕eнa ┐pкoc▓, ░eжим нa гpe╕кa }
     Print_mode = (Normal_mode, Highlight_mode, Error_mode);
     Status  = (Closed, Opened); { C║c▓o┐ниe нa пaнeлa: зa▓вopeн, о▓вopeн  }
     Field_pointer = ^Field_data;                   { Укaзa▓eл к║м пoлe▓o  }
     Field_data  =                                  { Дaнни зa пoлe▓o      }
       RECORD  Row_field, Col_field,               { Koopдинa▓и нa пoлe▓o  }
         Len_field    : BYTE;                      { Д║лжинa нa пoлe▓o     }
         Fore_field,
         Back_field   : BYTE;                  { Цв┐▓ нa cимвoли▓e и ┤oнa  }
         Help_field,                       { Hoмep на c║oб╣eниe пpи пoмo╣  }
         Init_field   : BYTE;                 { Hoмep на c║oб╣eниe пpи НП  }
         Test_proc    : Field_test;       { Ф│нк╢и┐ зa ▓ec▓вaнe нa пoлe▓o  }
         Find_error   :    BOOLEAN;       { Индикa▓op зa гpe╕кa нa пoлe▓o  }
         Kind_field   :    Field_type;                    { Tип нa пoлe▓o  }
         CASE Field_type OF         { Bapиaн▓нa ╖ac▓ нa дaнни▓e зa пoлe▓o  }
           Inp_float, Out_float,Inp_fixed, Out_fixed:
             ( Rl     :   ^REAL;      { Укaзa▓eл к║м пoлe▓o o▓ peaлeн ▓ип  }
               Min_real,Max_real: REAL; { Гpaни╢и зa c▓oйнoc▓▓a нa пoлe▓o  }
               Dec_pl : BYTE); { Бpoй нa знa╢и▓e cлeд дece▓и╖нa▓a зaпe▓a┐  }
           Inp_intg, Out_intg:
             ( Intg   :    ^INTEGER;   { Укaзa▓eл к║м пoлe▓o o▓ ╢┐л ▓ип    }
               Min_intg , Max_intg: INTEGER);     { Гpaни╢и зa c▓oйнoc▓▓a  }
           Inp_str, Out_str, Out_text:
             ( St: ^Str_field);     { Укaзa▓eл к║м пoлe▓o o▓ cимволен низ  }
           Inp_char, Out_char:
             ( Ch     : ^CHAR;      { Укaзa▓eл к║м пoлe▓o o▓ cимвoлeн ▓ип  }
               Inq_letters: Str_field);               { Дoп│c▓ими cимвoли  }
           Inp_enum   :
             ( P_Opt  : ^BYTE;       { Укaзa▓eл к║м пpoмeнливa▓a-peз│л▓a▓  }
               P_enum : ^Arr_str_field;   { Укaзa▓eл к║м ▓eкc▓oвe▓e нa     }
                                          { aл▓epнa▓иви▓e                  }
             Numb_enum: BYTE)             { Бpoй нa aл▓epнa▓иви▓e          }
         END;
     Panel_pointer = ^Panel_data;                    { Укaзa▓eл к║м пaнeл  }
     Panel_data =                                    { Дaнни зa пaнeл      }
       RECORD Start_row,Start_col: BYTE; { Koopдинa▓и нa го░ни┐ л┐в ║г║л   }
         Height, Width    : BYTE;        { Paзмepи нa пpoзope╢a            }
         Window_numb      : BYTE;        { Hoмep нa пpoзope╢               }
         State            : Status;      { C║c▓o┐ниe нa пaнeлa             }
         Root_field       : D_list;      { Укaзa▓eл к║м cпиc║кa o▓ пoлe▓a  }
         Quit_flag,                      { Флaг зa ┤opcиpaн изxoд          }
         Update_flag      : BOOLEAN;     { Флaг зa aк▓│aлизиpaнe нa пaнeлa }
         Go_to_flag       : BOOLEAN;     { Флaг зa пpo╢eд│pa▓a Go_to       }
         Go_to_place      : D_pointer;   { Пoлe зa пpexoд                  }
         Init_proc        : Panel_init_field; { Пpo╢eд│pa зa HП            }
         Help_proc        : Panel_help_field  { Пpo╢eд│pa зa пoмo╣         }
       END;
  VAR
    Root_panel      : S_list;          { Укaзa▓eл к║м cпиc║кa нa пaнeли▓е  }
    Active_panel    : Panel_pointer;   { Aк▓ивeн (пoдpaзбиpa╣ ce) пaнeл    }
    Curr_fore_clr   : BYTE;         { Teк│╣ ╢в┐▓ нa cимвoли▓e в пoлe▓o     }
    Curr_back_clr   : BYTE;         { Teк│╣ ╢в┐▓ нa ┤oнa в пoлe▓o          }
    Error_fore_color: BYTE;         { Teк│╣ ╢в┐▓ нa cимвoли▓e пpи гpe╕кa   }
    Error_back_color: BYTE;         { Teк│╣ ╢в┐▓ нa ┤oнa пpи гpe╕кa        }
    Insert_mode     : BOOLEAN; { Peжим зa в║вeждaнe - вм║квaнe/зaмec▓вaнe  }
    Move_Keys,                       { Mнoжec▓вo o▓ cимвoли зa │пpaвлeниe  }
    Input_characters: SET OF CHAR;   { Mнoжec▓вo o▓ вxoдни cимвoли         }
{$F+ ----------------------------------------------------------------------}
PROCEDURE Proc_del_field                 { Из▓pивa ин┤opмa╢и┐▓a зa пoлe▓o  }
          (Point : POINTER);             { Укaзa▓eл к║м дaнни▓e нa пoлe▓o  }
BEGIN { Proc_del_field }       { Пpo╢eд│pa▓a ce извиквa o▓ мoд│лa D_lists  }
  WITH Field_pointer (Point)^ DO
    IF Kind_field = Out_text THEN     { Aкo пoлe▓o e ▓eкc▓oвo, из▓pивa     }
      DISPOSE(St);                    { o▓дeлeнa▓a зa нeгo пaмe▓           }
  DISPOSE (Field_pointer(Point))      { Ocвoбoждaвa  пaмe▓▓a зa пoлe▓o     }
END { Proc_del_field };
{--------------------------------------------------------------------------}
PROCEDURE Disp_field (P:D_pointer); FORWARD; { Извeждa нa eкpaнa eднo пoлe }
{$F-  ---------------------------------------------------------------------}
FUNCTION Define_panel;                { Oб┐в┐вa ocнoвни▓e дaнни зa пaнeлa  }
  VAR Found : S_pointer;       Bool  :  BOOLEAN;         Part  :  BYTE;
BEGIN { Define_panel }                         { T║pcи пaнeл c нoмep Numb  }
  IF S_insert_node (Root_panel, Numb, Found) THEN
    BEGIN                             { Aкo нe нaмepи - oб┐в┐вa нoв пaнeл  }
      NEW (Active_panel);             { Peзepвиpa пaмe▓ зa пaнeлa          }
      Found^.S_data := Active_panel;
      WITH Active_panel^ DO           { Bзeмa нoмep нa cвoбoдeн пpoзope╢   }
        BEGIN  Window_numb := Get_free_window;
          State := Closed;    { C║здaвa пpaзeн дв│cв║pзaн cпиc║к зa пoлe▓a }
          D_init (Root_field, Disp_field, D_null_func, Proc_del_field);
        END
    END    { Пaнeл c ▓oзи нoмep вe╖e c║╣ec▓в│вa - пapaмe▓pи▓e м│ ╣e б║дa▓  }
  ELSE       { пpoмeнeни в c║o▓вe▓c▓виe c нoви▓e пapaмe▓pи нa пpo╢eд│pa▓a  }
      Active_panel:= Found^.S_data;
  WITH Active_panel^ DO
    BEGIN
      IF State = Closed THEN
        BEGIN               { Kopигиpa ╢вe▓a нa cимвoли▓e, aкo имa гpe╕кa  }
         Fore_clr := Fore_clr AND (Blink + 7);  Back_clr := Back_clr AND 7;
                      { Зaдaвa ocнoвни▓e пapaмe▓pи нa пpoзope╢a зa пaнeлa  }
         IF Define_window (Window_numb, Row_pos, Col_pos, Height_panel,
                         Width_panel, Fore_clr, Back_clr, Box, Title) THEN
           BEGIN
             Define_panel := TRUE;
             IF Box = No_box THEN   { Oпpeдeл┐ "гaбapи▓ни▓e" paзмepи нa    }
               Part := 0            { пaнeл в зaвиcимoc▓ o▓ ▓oвa дaли имa  }
             ELSE                   { paмкa или н┐мa                       }
               Part := 2;
             Height := Height_panel - Part;  Width := Width_panel  - Part;
             Init_proc  := Init_procedure;   Help_proc := Help_procedure;
             Update_flag      := FALSE; { Флaг зa aк▓│aлизиpaнe нa пaнeлa  }
             Quit_flag        := FALSE;     { Флaг зa нaп│cкaнe нa пaнeлa  }
             Go_to_flag       := FALSE          { Флaг зa пpexoд к║м пoлe  }
           END
         ELSE                        { Гpe╕кa пpи o▓вap┐нe▓o нa пpoзope╢a  }
           BEGIN
             Define_panel := FALSE;               { Ocвoбoждaвa пpoзope╢a  }
             Bool := Release_window(Window_numb);
             Release_panel (Numb)
           END
        END
      ELSE
        Define_panel := FALSE
    END
END { Define_panel };
{--------------------------------------------------------------------------}
FUNCTION Test_in_field           { Пpoвep┐вa дaли пoлe▓o e вxoднo-изxoднo  }
         (Place : D_pointer      { Укaзa▓eл к║м cпиc║кa нa пoлe▓a▓а        }
         ): BOOLEAN;        { Peз│л▓a▓:   TRUE  - пoлe▓o e вxoднo-изxoднo  }
                            {             FALSE - пoлe▓o e изxoднo         }
BEGIN { Test_in_field }
  WITH Field_pointer (D_get_data(Place))^ DO
    IF Kind_field IN [Inp_float,Inp_fixed,Inp_str,
                      Inp_char, Inp_intg, Inp_enum] THEN
      Test_in_field := TRUE
    ELSE
      Test_in_field := FALSE
END { Test_in_field };
{--------------------------------------------------------------------------}
FUNCTION Find_in_field             { T║pcи cлeдвa╣o▓o вxoднo-изxoднo пoлe  }
         (Curr_place    : D_pointer;    { Teк│╣o пoлe - нa╖aлo зa ▓║pceнe  }
      VAR New_curr_place: D_pointer;    { Haмepeнo пoлe                    }
          Func          : Find_function { Ф│нк╢и┐ зa ▓║pceнe               }
          ) : BOOLEAN;          { Peз│л▓a▓ TRUE  - нaмepeнo e ▓aкoвa пoлe  }
                                {          FALSE - н┐мa ▓aкoвa пoлe        }
  VAR  Temp_place : D_pointer;
       Found      : BOOLEAN;
BEGIN { Find_in_field }
  Found := FALSE;      Temp_place := Curr_place;
  WHILE  NOT FOUND DO
    BEGIN                                         { T║pcи cлeдвa╣o▓o пoлe  }
      IF Func (Temp_place, Temp_place) THEN
        BEGIN           { O▓кpи▓o e пoлe - пpoвepкa дaли e вxoднo-изxoднo  }
          IF Test_in_field (Temp_place) THEN
            BEGIN           { Пoлe▓o e вxoднo-изxoднo - кpaй нa ▓║pceнe▓o  }
              New_curr_place := Temp_place;
              Found := TRUE;          Find_in_field := TRUE
            END
        END
      ELSE
        BEGIN                   { He e o▓кpи▓o e пoлe - кpaй нa ▓║pceнe▓o  }
          New_curr_place := Curr_place;
          Found := TRUE;             Find_in_field := FALSE
        END
    END { While}
END { Find_in_field };
{--------------------------------------------------------------------------}
PROCEDURE Go_to;   { Уc▓aнoв┐вa к│░▒о░а в║в вxoднo-изxoднo пoлe c          }
                   { кoopдинa▓и Row, Col или в cлeдвa╣o▓o вxoднo-изxoднo   }
                   { пoлe нa пaнeлa Numb. Пaнeл║▓ ▓p┐бвa дa e o▓вopeн      }
  VAR Temp   : D_pointer;      T_panel: S_pointer;      Key_el : INTEGER;
BEGIN { Go_to }
  IF S_search_node (Root_panel, Numb, T_panel) THEN
    WITH Panel_pointer (T_panel^.S_data)^ DO
      IF State = Opened THEN                    {  Пaнeл║▓ o▓вopeн ли e ?  }
       BEGIN     Go_to_flag := FALSE;
         Key_el := (Row SHL 8) + Col;     { Фopмиpaнe нa кл╛╖ зa ▓║pceнe   }
                                          { T║pceнe в cпиc║кa нa пoлe▓a▓a  }
         IF D_search_node(Root_field, Key_el,Temp) THEN
           IF Test_in_field (Temp) THEN
             BEGIN                { Пpoвepкa дaли пoлe▓o e вxoднo-изxoднo  }
               Go_to_place := Temp;          Go_to_flag := TRUE
             END
           ELSE               { T║pceнe нa cлeдвa╣o▓o вxoднo-изxoднo пoлe  }
             IF Find_in_field (Temp, Temp, D_find_next) THEN
               BEGIN
                 Go_to_place := Temp;        Go_to_flag := TRUE
               END
       END
END { Go_to };
{--------------------------------------------------------------------------}
FUNCTION Close_panel;                          { Из▓pивa пaнeлa o▓ eкpaнa  }
  VAR Temp: S_pointer;
BEGIN { Close_panel }
  IF S_search_node (Root_panel, Numb, Temp) THEN
    BEGIN
      WITH Panel_pointer (Temp^.S_data)^ DO
        IF State = Opened THEN
          IF Close_window (Window_numb) THEN { Зa▓вap┐ пpoзope╢a нa пaнeлa }
            State := Closed
          ELSE
            Close_panel := FALSE;
      Close_panel := TRUE
    END
  ELSE                                          { H┐мa пaнeл c ▓oзи нoмep  }
    Close_panel := FALSE
END { Close_panel };
{--------------------------------------------------------------------------}
{$F+ } {Пpo╢eд│pa▓a ce извиквa o▓ Release_panel пocpeдc▓вoм S_delete_node  }
PROCEDURE Proc_del_panel                 { Из▓pивa ин┤opмa╢и┐▓a зa пaнeлa  }
          (Point : POINTER);
  VAR B : BOOLEAN;                                   { Пoмo╣нa пpoмeнливa  }
BEGIN  { Proc_del_panel }
  WITH Panel_pointer(Point)^ DO
    BEGIN                         { Из▓pивa ин┤opмa╢и┐▓a зa вcи╖ки пoлe▓a  }
      D_delete_list (Root_field);
      B := Release_window (Window_numb)           { Ocвoбoждaвa пpoзope╢a  }
    END;
  DISPOSE (Panel_pointer(Point))
END { Proc_del_panel };
{$F- ----------------------------------------------------------------------}
PROCEDURE Release_panel;                  { Из▓pивa ин┤opмa╢и┐▓a зa пaнeл  }
  VAR B : BOOLEAN;
BEGIN { Release_panel }
  B := Close_panel(Numb);             { Зa▓вap┐ пaнeлa, aкo нe e зa▓вopeн  }
  B := S_delete_node (Root_panel, Numb)      { Из▓pивa дaнни▓e зa панела   }
END { Release_panel };
{--------------------------------------------------------------------------}
FUNCTION Define_field           { Bкл╛╖вa нoвo пoлe в cпиc║кa нa пoлe▓a▓а  }
         (Root_field     :  D_list;                { Ha╖aлo нa cпиc║кa     }
          Row_pos,Col_pos:  BYTE                   { Koopдинa▓и нa пoлe▓o  }
          ):                Field_pointer;     { Укaзa▓eл к║м нoвo▓o пoлe  }
  VAR Key_el    : INTEGER;                     { Kл╛╖ нa пoлe▓o            }
      Temp      : D_pointer;                   { Укaзa▓eл к║м пoлe▓o       }
      New_field : Field_pointer;         { Укaзa▓eл к║м дaнни▓е нa пoлe▓o  }
      B         : BOOLEAN;                     { Пoмo╣нa пpoмeнливa        }
BEGIN { Define_field }
  Key_el := (Row_pos SHL 8) + Col_pos;     { Фopмиpaнe нa кл╛╖ зa ▓║pceнe  }
  IF D_search_node(Root_field, Key_el, Temp) THEN { Aкo имa пoлe c ▓aкивa  }
    New_field := D_get_data(Temp)          { кoopдинa▓и, взeмa aдpeca м│   }
  ELSE
    BEGIN   NEW (New_field);    { Bкл╛╖вa нoвo пoлe в cпиc║кa нa пoлe▓a▓a  }
      B := D_insert_node(Root_field, Key_el, POINTER(New_field), Temp);
    END;
  Define_field := New_field
END { Define_field };
{--------------------------------------------------------------------------}
PROCEDURE Copy_fields                 { Зaпиcвa ocнoвни▓e дaнни зa пoлe▓o  }
          (New_field      : Field_pointer;
           Row_pos,Col_pos: BYTE;         { Коо░дина▓и на поле▓о           }
           Len            : BYTE;         { Ши░о╖ина на поле▓о             }
           Kind_Curr_field: Field_type;   { Тип на поле▓о                  }
           Help_num,                 { Логи╖е▒ки номе░ на поле▓о п░и помо╣ }
           Init_num       : BYTE;        {Логи╖е▒ки номе░ на поле▓о п░и НП }
           Test_procedure : Field_test); { Те▒▓ова ┤│нк╢и┐                 }
BEGIN  { Copy_fields }
  WITH  New_field^ DO
    BEGIN
      Row_field  := Row_pos;         Col_field  := Col_pos;
      Help_field := Help_num;        Init_field := Init_num;
      Fore_field := Curr_fore_clr;   Back_field := Curr_back_clr;
      Kind_field := Kind_Curr_Field; Len_field  := Len;
      Find_error := FALSE;           Test_proc  := Test_procedure
    END
END { Copy_fields };
{--------------------------------------------------------------------------}
FUNCTION Test_field  { Пpoвep┐вa дaли пoлe▓o пoпaдa в гpaни╢и▓e нa пaнeлa  }
         (Row_pos, Col_pos, Len,
          Height, Width: BYTE): BOOLEAN;
BEGIN { Tets_field }
  IF (Row_pos >= 1) AND (Row_pos <= Height) AND
     (Col_pos >= 1) AND (Col_pos+Len < Width) THEN
    Test_field := TRUE
  ELSE
    Test_field := FALSE
END { Test_field };
{--------------------------------------------------------------------------}
PROCEDURE In_out_float;                   { Oб┐в┐вa вxoднo-изxoднo пoлe за }
  VAR New_field: Field_pointer;           { eкcпoнeн╢иален ┤opмa▓          }
BEGIN { In_out_float }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
                                              { Koпиpa oб╣и▓e дaнни        }
        Copy_fields (New_field, Row_pos, Col_pos, Len,
                     Inp_Float, Help_num, NP_num, Test_real);
        WITH  New_field^ DO
          BEGIN                  { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
            Rl       := @R;
            Min_real := Min;    Max_real  := Max
          END
     END
END { In_out_float };
{--------------------------------------------------------------------------}
PROCEDURE In_out_fixed;  { Oб┐в┐вa вxoднo-изxoднo пoлe за дece▓и╖eн ┤opмa▓ }
  VAR  New_field: Field_pointer;
BEGIN { In_out_fixed }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
        Copy_fields (New_field, Row_pos, Col_pos, Len, Inp_Fixed,
                     Help_num, NP_num, Test_real);  { Koпиpa oб╣и▓e дaнни }
        WITH  New_field^ DO     { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
          BEGIN   Rl := @R;         Dec_pl   := Dec_p;
            Min_real := Min;        Max_real := Max
          END
      END
END { In_out_fixed };
{--------------------------------------------------------------------------}
PROCEDURE In_out_intg;           { Oб┐в┐вa вxoднo-изxoднo пoлe за ╢┐л ▓ип  }
  VAR New_field: Field_pointer;
BEGIN { In_out_intg }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
                                      { Koпиpa▓ ce oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field, Row_pos, Col_pos, Len,
                    Inp_intg, Help_num, NP_num, Test_intg);
        WITH  New_field^ DO
          BEGIN                  { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
            Intg := @I;    Min_intg := Min;         Max_intg := Max
          END
      END
END { In_out_intg };
{--------------------------------------------------------------------------}
PROCEDURE In_out_enum;        { Oб┐в┐вa вxoднo-изxoднo пoлe за избpoeн ▓ип }
  VAR New_field: Field_pointer;
BEGIN { In_out_intg }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field, Row_pos, Col_pos, Len,
                     Inp_enum, Help_num, NP_num, Test_enum);
        WITH  New_field^ DO      { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
          BEGIN  P_opt := @Option;  P_enum := @Enum;   Numb_enum := N_enum;
            IF (Option < 1) OR (Option > N_enum) THEN
              Option := 1
          END
      END
END { In_out_intg };
{--------------------------------------------------------------------------}
PROCEDURE In_out_string;    { Oб┐в┐вa вxoднo-изxoднo пoлe за cимвoлeн низ  }
  VAR  New_field: Field_pointer;
BEGIN { In_out_string }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field, Row_pos, Col_pos, Len,
                     Inp_Str, Help_num, NP_num, Test_string);
        New_field^.St := @S
      END
END { In_out_string };
{--------------------------------------------------------------------------}
PROCEDURE In_out_char;      { Oб┐в┐вa вxoднo-изxoднo пoлe o▓ cимвoлeн ▓ип  }
 VAR  New_field:  Field_pointer;
BEGIN { In_out_char }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, 1, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field, Row_pos, Col_pos, 1,
                     Inp_char, Help_num, NP_num, Test_char);
        WITH  New_field^ DO
          BEGIN                  { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
            Ch := @C;        Inq_letters := Letters
          END
      END
END { In_out_char };
{--------------------------------------------------------------------------}
PROCEDURE Output_float;   { Oб┐в┐вa изxoднo пoлe за eкcпoнeн╢иален ┤opмa▓  }
 VAR  New_field : Field_pointer;
BEGIN { Output_float }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos,Len,Out_float,0,0,No_test);
        New_field^.Rl := @R
      END
END { Output_float };
{--------------------------------------------------------------------------}
PROCEDURE Output_fixed;        { Oб┐в┐вa изxoднo пoлe за дece▓и╖eн ┤opмa▓  }
  VAR  New_field: Field_pointer;
BEGIN { Output_fixed }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos,Len,Out_Fixed,0,0,No_test);
        New_field^.Rl  := @R;    { Koпиpa cпe╢и┤и╖ни▓e дaнни зa ▓oвa пoлe  }
        New_field^.Dec_pl := Dec_p
      END
END { Output_fixed };
{--------------------------------------------------------------------------}
PROCEDURE Output_intg;                  { Oб┐в┐вa изxoднo пoлe за ╢┐л ▓ип  }
  VAR  New_field: Field_pointer;
BEGIN { Output_intg }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field:= Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos, Len,Out_intg,0,0,No_test);
        New_field^.Intg  := @I
      END
END { Output_intg };
{--------------------------------------------------------------------------}
PROCEDURE Output_string;           { Oб┐в┐вa изxoднo пoлe за cимвoлeн низ  }
  VAR  New_field: Field_pointer;
BEGIN { Output_string }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos,Len,Out_str,0,0,No_test);
        New_field^.St := @S
      END
END { Output_string };
{--------------------------------------------------------------------------}
PROCEDURE Output_text;                            { Oб┐в┐вa ▓eкc▓oвo пoлe  }
  VAR  New_field: Field_pointer;
BEGIN { Output_text }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, Len, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos,Len,Out_text,0,0,No_test);
        NEW (New_field^.St); { Peзepвиpa ce пaмe▓ зa ▓eкc▓a нa  ▓oвa пoлe  }
        New_field^.St^ := S                   { Koпи░а ▓eкc▓а в ▓aзи пaмe▓ }
      END
END { Output_text };
{--------------------------------------------------------------------------}
PROCEDURE Output_char;             { Oб┐в┐вa изxoднo пoлe o▓ cимвoлeн ▓ип  }
  VAR  New_field: Field_pointer;
BEGIN { Output_char }
  WITH Active_panel^ DO
    IF Test_field (Row_pos, Col_pos, 1, Height, Width) THEN
      BEGIN                                   { Peзepвиpa дaнни зa пoлe▓o  }
        New_field := Define_field (Root_field,Row_pos,Col_pos);
                                          { Koпиpa oб╣и▓e дaнни зa пoлe▓o  }
        Copy_fields (New_field,Row_pos,Col_pos,1,Out_char, 0, 0, No_test);
        New_field^.Ch := @C
      END
END { Output_char };
{--------------------------------------------------------------------------}
PROCEDURE Set_field_color;  { Зaдaвa ╢в┐▓ нa cимвoли▓e и ┤oнa зa пoлe▓a▓a  }
BEGIN { Set_field_color }
  Curr_fore_clr := Fore AND (Blink OR 7);
  Curr_back_clr := Back AND 7
END { Set_field_color };
{--------------------------------------------------------------------------}
PROCEDURE Set_error_color;   { Зaдaвa ╢в┐▓ нa cимвoли▓e и ┤oнa пpи гpe╕кa  }
BEGIN { Set_error_color }
  Error_fore_color := Fore AND (Blink OR 7);
  Error_back_color := Back AND 7
END { Set_error_color };
{--------------------------------------------------------------------------}
PROCEDURE Remove_field;       { O▓c▓paн┐ва пoлe c кoopдинa▓и Row, Col o▓   }
  VAR Temp   : BOOLEAN;       { пaнeлa Numb. Пaнeл║▓ ▓p┐бвa дa e aк▓ивeн   }
      T_panel: S_pointer;      Key_el : INTEGER;
BEGIN { Remove_field }                   { T║pcи пaнeл c пoco╖eни┐ нoмep   }
  IF S_search_node (Root_panel, Numb, T_panel) THEN
    WITH Panel_pointer (T_panel^.S_data)^ DO
      BEGIN  Key_el := (Row SHL 8) + Col;      { Фopмиpa кл╛╖ зa ▓║pceнe   }
        Temp := D_delete_node (Root_field, Key_el)  { Из▓pивa н│жнo▓o пoлe }
      END
END { Remove_field };
